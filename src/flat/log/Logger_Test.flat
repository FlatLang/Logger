package flat/log

import flat/log/Logger

import static flat/colorizer/Colorizer

testable class {
  init_test init() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_PREFIX = false
    Logger.DEFAULT_SHOW_FORMATTING = true
    Logger.DEFAULT_LINE_LENGTH = null
    Logger.DEFAULT_SPLIT_ON_WORD = true
    Logger.DEFAULT_LINE_PREFIX = null
    Logger.DEFAULT_LINE_SUFFIX = null
    Logger.DEFAULT_PREFIX = null
    Logger.DEFAULT_SUFFIX = null
    Logger.DEFAULT_PREFIX_SEPARATOR = " - "
    Logger.enableAllLogs()
  }

  async test `can log a basic trace message`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.TRACE
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.trace("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt log a basic trace message if logging level is DEBUG`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.DEBUG
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.trace("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can log a basic debug message`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.DEBUG
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.debug("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt log a basic debug message if logging level is INFO`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.debug("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can log a basic info message`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt log a basic info message if logging level is WARN`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.WARN
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can log a basic warn message`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.WARN
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.warn.captureOutput({
      log.warn("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt log a basic warn message if logging level is ERROR`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.ERROR
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.warn.captureOutput({
      log.warn("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can log a basic error message`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.ERROR
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.error.captureOutput({
      log.error("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt log a basic error message if logging level is FATAL`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.FATAL
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.error.captureOutput({
      log.error("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can log a basic fatal message`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.FATAL
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.error.captureOutput({
      log.fatal("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt log a basic fatal message if logging level is OFF`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.OFF
    Logger.DEFAULT_SHOW_FORMATTING = false

    let log = Logger(Object.class)

    let output = Console.error.captureOutput({
      log.fatal("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can filter logs based on exact klass name`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs(Object.class)

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can reenable filtered logs based on exact klass name`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs(Object.class)
    Logger.enableLogs(Object.class)

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on exact label`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test log")

    let log = Logger(label: "test log")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can reenable filtered logs based on exact label`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test log")
    Logger.enableLogs("test log")

    let log = Logger(label: "test log")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on wildcard label`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test *")

    let log = Logger(label: "test log")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can reenable filtered logs based on wildcard label`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test *")
    Logger.enableLogs("test *")

    let log = Logger(label: "test log")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on wildcard label with single wildcard character in between literals`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu")

    let log = Logger(label: "test log aoeu")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can reenable filtered logs based on wildcard label with single wildcard character in between literals`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu")
    Logger.enableLogs("test * aoeu")

    let log = Logger(label: "test log aoeu")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on wildcard label with single wildcard at very end`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test*")

    let log = Logger(label: "test")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can reenable filtered logs based on wildcard label with single wildcard at very end`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test*")
    Logger.enableLogs("test*")

    let log = Logger(label: "test")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on wildcard label with two wildcards at very end`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test**")

    let log = Logger(label: "test")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can reenable filtered logs based on wildcard label with two wildcards at very end`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test**")
    Logger.enableLogs("test**")

    let log = Logger(label: "test")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on wildcard label with two wildcard characters both in between string literals`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu* a")

    let log = Logger(label: "test log aoeuuauaua a")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `doesnt filter logs based on wildcard label with two wildcard characters both in between string literals and doesnt match first literal`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu* a")

    let log = Logger(label: "teest log aoeuaaa a")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt filter logs based on wildcard label with two wildcard characters both in between string literals and doesnt match middle literal`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu* a")

    let log = Logger(label: "test log aooeuuauau a")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on wildcard label with two wildcard characters both in between string literals and middle literal match is empty`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu* a")

    let log = Logger(label: "test  aoeuuauau a")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `doesnt filter logs based on wildcard label with two wildcard characters both in between string literals and doesnt match last literal`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu* a")

    let log = Logger(label: "test log aoeuuauaua")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can reenable filtered logs based on wildcard label with two wildcard characters both in between string literals`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu* a")
    Logger.enableLogs("test * aoeu* a")

    let log = Logger(label: "test log aoeuuauaua a")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on wildcard label with two wildcard characters and the last at the very end`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu*")

    let log = Logger(label: "test log aoeu")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `doesnt filter logs based on wildcard label with two wildcard characters and the last at the very end where it doesnt match`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu*")

    let log = Logger(label: "test log aoe")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can reenable filtered logs based on wildcard label with two wildcard characters and the last at the very end`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("test * aoeu*")
    Logger.enableLogs("test * aoeu*")

    let log = Logger(label: "test log aoeu")

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }

  async test `can filter logs based on exact klass name label`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("flat/colorizer/Colorizer")

    let log = Logger(Colorizer.class)

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `can filter logs based on wildcard klass name label`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("flat/colorizer/*")

    let log = Logger(Colorizer.class)

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(Array())
  }

  async test `doesnt filter logs based on non-matched wildcard klass name label`() {
    Logger.DEFAULT_LOGGING_LEVEL = Logger.INFO
    Logger.DEFAULT_SHOW_FORMATTING = false
    Logger.disableLogs("flat/colorizer/*")

    let log = Logger(Object.class)

    let output = Console.out.captureOutput({
      log.info("hey")
    })

    expect(output).toBe(["hey"])
  }
}
