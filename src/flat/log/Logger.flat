package flat/log

import flatlang/time/DateTime

import flatlang/regex/Pattern
import flatlang/regex/RegexStringExtensions

import static flat/colorizer/Colorizer

class {
  visible let static Int TRACE = 6
  visible let static Int DEBUG = 5
  visible let static Int INFO = 4
  visible let static Int WARN = 3
  visible let static Int ERROR = 2
  visible let static Int FATAL = 1
  visible let static Int OFF = 0

  public var static Int DEFAULT_LOGGING_LEVEL = INFO
  public var static Bool DEFAULT_SHOW_PREFIX = false
  public var static Bool DEFAULT_SHOW_FORMATTING = false
  public var static Int DEFAULT_LINE_LENGTH = null
  public var static Bool DEFAULT_SPLIT_ON_WORD = true

  public var static Int FORCE_LOGGING_LEVEL = null
  public var static Bool FORCE_SHOW_PREFIX = null
  public var static Bool FORCE_SHOW_FORMATTING = null
  public var static Int FORCE_LINE_LENGTH = null
  public var static Bool FORCE_SPLIT_ON_WORD = null

  static {
    if (let level = System.getEnv("LOGGING_DEFAULT_LOGGING_LEVEL")) {
      let levelValue = match (level) {
        "TRACE" => TRACE
        "DEBUG" => DEBUG
        "INFO" => INFO
        "WARN" => WARN
        "ERROR" => ERROR
        "FATAL" => FATAL
      }

      DEFAULT_LOGGING_LEVEL = levelValue
    }
    if (let showPrefix = System.getEnv("LOGGING_DEFAULT_SHOW_PREFIX")) {
      DEFAULT_SHOW_PREFIX = Bool.fromString(showPrefix)
    }
    if (let showFormatting = System.getEnv("LOGGING_DEFAULT_SHOW_FORMATTING")) {
      DEFAULT_SHOW_FORMATTING = Bool.fromString(showFormatting)
    }
    if (let forceLevel = System.getEnv("LOGGING_FORCE_LOGGING_LEVEL")) {
      let levelValue = match (forceLevel) {
        "TRACE" => TRACE
        "DEBUG" => DEBUG
        "INFO" => INFO
        "WARN" => WARN
        "ERROR" => ERROR
        "FATAL" => FATAL
      }

      FORCE_LOGGING_LEVEL = levelValue
    }
    if (let forceShowPrefix = System.getEnv("LOGGING_FORCE_SHOW_PREFIX")) {
      FORCE_SHOW_PREFIX = Bool.fromString(forceShowPrefix)
    }
    if (let forceShowFormatting = System.getEnv("LOGGING_FORCE_SHOW_FORMATTING")) {
      FORCE_SHOW_FORMATTING = Bool.fromString(forceShowFormatting)
    }
  }

  let static Logger DEFAULT = Logger()

  let Int _loggingLevel = null
  visible let Int loggingLevel {
    get {
      return if (FORCE_LOGGING_LEVEL != null) {
        FORCE_LOGGING_LEVEL
      } else if (_loggingLevel != null) {
        _loggingLevel
      } else {
        DEFAULT_LOGGING_LEVEL
      }
    }
  }

  let Bool _showPrefix = null
  visible let Bool showPrefix {
    get {
      return if (FORCE_SHOW_PREFIX != null) {
        FORCE_SHOW_PREFIX
      } else if (_showPrefix != null) {
        _showPrefix
      } else {
        DEFAULT_SHOW_PREFIX
      }
    }
  }

  let Bool _showFormatting = null
  visible let Bool showFormatting {
    get {
      return if (FORCE_SHOW_FORMATTING != null) {
        FORCE_SHOW_FORMATTING
      } else if (_showFormatting != null) {
        _showFormatting
      } else {
        DEFAULT_SHOW_FORMATTING
      }
    }
  }

  let Int _lineLength = null
  visible let Int lineLength {
    get {
      return if (FORCE_LINE_LENGTH != null) {
        FORCE_LINE_LENGTH
      } else if (_lineLength != null) {
        _lineLength
      } else {
        DEFAULT_LINE_LENGTH
      }
    }
  }

  let Bool _splitOnWord = null
  visible let Bool splitOnWord {
    get {
      return if (FORCE_SPLIT_ON_WORD != null) {
        FORCE_SPLIT_ON_WORD
      } else if (_splitOnWord != null) {
        _splitOnWord
      } else {
        DEFAULT_SPLIT_ON_WORD
      }
    }
  }

  Array<filter(String) -> String> filters = Array()

  public construct(
    private Class loggerClass = null,
    private String: label = null,
    Int: loggingLevel = null,
    Bool: showPrefix = null,
    Bool: showFormatting = null,
    Int: lineLength = null,
    Bool: splitOnWord = null
  ) {
    _loggingLevel = loggingLevel
    _showPrefix = showPrefix
    _showFormatting = showFormatting
    _lineLength = lineLength
    _splitOnWord = splitOnWord
  }

  getPrefix(Int level) -> String {
    if (!showPrefix) {
      return ""
    }

    let levelString = match (level) {
      TRACE => "TRACE"
      DEBUG => "DEBUG"
      INFO => "INFO"
      WARN => "WARN"
      ERROR => "ERROR"
      FATAL => "FATAL"
    }

    let timestamp = DateTime.now().toIsoString()
    let classPrefix = loggerClass ? loggerClass.location + " " : ""
    let labelPrefix = label ? label + " " : ""

    let suffix = " #{classPrefix}#{labelPrefix}".trimEnd()
    let content = "[#{timestamp}] [#{levelString}]" + suffix

    return if (showFormatting) {
      let colored = match (level) {
        TRACE => cyanBackground(content)
        DEBUG => greenBackground(content)
        INFO => grayBackground(content)
        WARN => yellowBackground(content)
        ERROR => redBackground(content)
        FATAL => redBackground(content)
      }

      colored + " - "
    } else {
      content + " - "
    }
  }

  public addFilter(filter(String) -> String) {
    filters.add(filter)
  }

  logMessage(String message, String level, Bool newLine = true) {
    throw Exception("Not implemented")
  }

  formatContent(var String content, Int level) -> String {
    filters.forEach({ content = (String)_(content) })

    if (_lineLength != null) {
      content = content
        .split(/\n/)
        .map((line) => {
          let trimmedLines = Array<String>()

          var i = 0

          while (i < line.count) {
            if (i + lineLength >= line.count) {
              trimmedLines.add(line.substring(i).trimEnd())
              break
            }

            let splitIndex = splitOnWord ?
              line.lastIndexOf(String.WHITESPACE, start: i + lineLength) + 1 :
              i + lineLength

            let trimmedLine = line.substring(i, splitIndex).trimEnd()

            trimmedLines.add(trimmedLine)

            i = splitIndex
          }

          return trimmedLines
        })
        .map({ "#{_.join("\n")}" })
        .join("\n")
    }

    if (!showFormatting) {
      return content
    }

    let formatted = match (level) {
      TRACE => cyan(content)
      DEBUG => green(content)
      INFO => content
      WARN => yellow(content)
      ERROR => red(content)
      FATAL => red(content)
    }

    return formatted
  }

  public trace(Object value, Bool: newLine = true) {
    if (loggingLevel >= TRACE) {
      let content = formatContent(value.toString(), TRACE)
      logMessage(getPrefix(TRACE) + content, "log", newLine)
    }
  }

  public debug(Object value, Bool: newLine = true) {
    if (loggingLevel >= DEBUG) {
      let content = formatContent(value.toString(), DEBUG)
      logMessage(getPrefix(DEBUG) + content, "log", newLine)
    }
  }

  public info(Object value, Bool: newLine = true) {
    if (loggingLevel >= INFO) {
      let content = formatContent(value.toString(), INFO)
      logMessage(getPrefix(INFO) + content, "log", newLine)
    }
  }

  public warn(Object value, Bool: newLine = true) {
    if (loggingLevel >= WARN) {
      let content = formatContent(value.toString(), WARN)
      logMessage(getPrefix(WARN) + content, "warn", newLine)
    }
  }

  public error(Object value, Bool: newLine = true) {
    if (loggingLevel >= ERROR) {
      let content = formatContent(value.toString(), ERROR)
      logMessage(getPrefix(ERROR) + content, "error", newLine)
    }
  }

  public fatal(Object value, Bool: newLine = true) {
    if (loggingLevel >= FATAL) {
      let content = formatContent(value.toString(), FATAL)
      logMessage(getPrefix(FATAL) + content, "error", newLine)
    }
  }
}